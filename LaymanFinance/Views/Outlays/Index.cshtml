@model IEnumerable<Outlay>
@{
    ViewData["Title"] = "Outlays";
}

<h1>Gaze at your outlays.</h1>

<div class="row">
    <div class="col-2">
        <h4>Date</h4>
    </div>
    <div class="col-2">
        <h4><a asp-route-sort="amount">Amount</a></h4>
    </div>
    <div class="col-2">
        <h4><a asp-route-sort="payee">Payee</a></h4>
    </div>
    <div class="col-4">
        <h4>Memo</h4>
    </div>
    <div class="col-2">
        <h4>Category</h4>
    </div>
</div>

@foreach (var outlay in Model)
{
    <div class="row">
        <div class="col-2">
            <p>@outlay.DateOccurred.ToShortDateString()</p>
        </div>
        <div class="col-2">
            <p>@outlay.Amount.ToString("c")</p>
            @*
                This is done when the model property is nullable.
                <p>@(Model.Amount.HasValue ? @Model.Amount.Value.ToString("c") : "No Value")</p>
            *@
        </div>
        <div class="col-2">
            <p>@outlay.Payee</p>
        </div>
        <div class="col-4">
            <p>@outlay.Memo</p>
        </div>
        <div class="col-2">
            <p>@outlay.Category.Name</p>
        </div>
    </div>
}
<a asp-action="EnterOutlay" asp-controller="Outlay">Add an Outlay.</a>

@section Scripts{
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chartist/0.11.0/chartist.min.js"></script>
    <script type="text/javascript">
        var outlayAllocation = JSON.parse('@Html.Raw(Newtonsoft.Json.JsonConvert.SerializeObject(Model.GroupBy(x => x.Category.Name).Select(x => new { Category = x.Key, Amount = x.Sum(y => y.Amount) })))');

    </script>
}